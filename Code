#include <cmath>
#include <functional>
#include <iostream>
#include <stack>
#include <utility>
#include <vector>

using real = long double;
const real epsilon = 0.000'000'1;

const real PI = 3.14159265358979323846;
//const real PI = acosl(-1);
//const real PI = 4.0 * atanl(1);
const real E = 2.7182818284590452354;

bool is_0(real x) {
  return std::abs(x) <= epsilon;
}

bool less_0(real x) {
  return x < -epsilon;
}

bool more_0(real x) {
  return x > epsilon;
}

bool not_more_0(real x) {
  return x <= epsilon;
}

bool not_less_0(real x) {
  return x >= -epsilon;
}

//____________________________________________________________________________________
struct Point {
  int64_t x;
  int64_t y;
  Point() = default;
  Point(const Point&) = default;
  ~Point() = default;
  explicit Point(int64_t x, int64_t y): x(x), y(y) {}

  friend std::ostream& operator<< (std::ostream& output, const Point& A) {
    output << A.x << ' ' << A.y;
    return output;
  }
};

Point operator+ (const Point& A, const Point& B) {
  return Point(A.x + B.x, A.y + B.y);
}

Point operator- (const Point& A, const Point& B) {
  return Point(A.x - B.x, A.y - B.y);
}

Point operator* (const Point& A, int64_t k) {
  return Point(A.x * k, A.y * k);
}

Point operator/ (const Point& A, real k) { // DIVISIBILITY REQUIRED
  return Point(A.x / k, A.y / k);
}

bool operator== (const Point& A, const Point& B) {
  return ((A.x == B.x) and (A.y == B.y));
}

bool operator!= (const Point& A, const Point& B) {
  return !(A == B);
}

real distance(const Point& A, const Point& B) {
  int64_t x_dist = B.x - A.x;
  int64_t y_dist = B.y - A.y;
  return std::sqrt(static_cast<real>(x_dist*x_dist + y_dist*y_dist));
}
//____________________________________________________________________________________
struct RealPoint {
  real x;
  real y;
  RealPoint() = default;
  explicit RealPoint(real x, real y): x(x), y(y) {}
  ~RealPoint() = default;
  explicit RealPoint(const Point& A): x(static_cast<real>(A.x)),
  y(static_cast<real>(A.y)) {}

  friend std::ostream& operator<< (std::ostream& output, const RealPoint& A) {
    output << A.x << ' ' << A.y;
    return output;
  }
};

RealPoint operator+ (const RealPoint& A, const RealPoint& B) {
  return RealPoint(A.x + B.x, A.y + B.y);
}

RealPoint operator- (const RealPoint& A, const RealPoint& B) {
  return RealPoint(A.x - B.x, A.y - B.y);
}

RealPoint operator* (const RealPoint& A, real k) {
  return RealPoint(A.x * k, A.y * k);
}

RealPoint operator/ (const RealPoint& A, real k) {
  return RealPoint(A.x / k, A.y / k);
}

bool operator== (const RealPoint& A, const RealPoint& B) {
  return (is_0(A.x - B.x) and is_0(A.y - B.y));
}

bool operator!= (const RealPoint& A, const RealPoint& B) {
  return !(A == B);
}

real distance(const RealPoint& A, const RealPoint& B) {
  real x_dist = B.x - A.x;
  real y_dist = B.y - A.y;
  return std::sqrt(x_dist*x_dist + y_dist*y_dist);
}
//____________________________________________________________________________________
struct Vector {
  int64_t x;
  int64_t y;
  Vector() = default;
  Vector(const Vector&) = default;
  ~Vector() = default;
  explicit Vector(int64_t x, int64_t y): x(x), y(y) {}
  explicit Vector(const Point& A): x(A.x), y(A.y) {}

  real length() const noexcept {
    return std::sqrt(static_cast<real>(x*x + y*y));
  }

  friend std::ostream& operator<< (std::ostream& output, const Vector& v) {
    output << v.x << ' ' << v.y;
    return output;
  }
};

Vector operator+ (const Vector& a, const Vector& b) noexcept {
  return Vector(a.x + b.x, a.y + b.y);
}

Vector operator- (const Vector& a, const Vector& b) noexcept {
  return Vector(a.x - b.x, a.y - b.y);
}

Vector operator* (const Vector& v, int64_t k) {
  return Vector(v.x * k, v.y * k);
}

bool operator== (const Vector& a, const Vector& b) {
  return ((a.x == b.x) and (a.y == b.y));
}

int64_t scalar_product(const Vector& a, const Vector& b) {
  return (a.x * b.x + a.y * b.y);
}

int64_t vector_product(const Vector& a, const Vector& b) {
  return (a.x * b.y - b.x * a.y);
}
//____________________________________________________________________________________
struct RealVector {
  real x;
  real y;
  RealVector() = default;
  RealVector(const RealVector&) = default;
  ~RealVector() = default;
  explicit RealVector(real x, real y): x(x), y(y) {}
  explicit RealVector(const RealPoint& A): x(A.x), y(A.y) {}
  explicit RealVector(const Vector& v): x(static_cast<real>(v.x)),
  y(static_cast<real>(v.y)) {}

  real length() const noexcept {
    return sqrtl(static_cast<real>(x*x + y*y));
  }

  friend std::ostream& operator<< (std::ostream& output, const RealVector& v) {
    output << v.x << ' ' << v.y;
    return output;
  }
};

RealVector operator+ (const RealVector& a, const RealVector& b) {
  return RealVector(a.x + b.x, a.y + b.y);
}

RealVector operator- (const RealVector& a, const RealVector& b) {
  return RealVector(a.x - b.x, a.y - b.y);
}

RealVector operator* (const RealVector& v, real k) {
  return RealVector(v.x * k, v.y * k);
}

RealVector operator/ (const RealVector& v, real k) {
  return RealVector(v.x / k, v.y / k);
}

bool operator== (const RealVector& a, const RealVector& b) {
  return (is_0(a.x - b.x) and is_0(a.y - b.y));
}

real scalar_product(const RealVector& a, const RealVector& b) {
  return (a.x * b.x + a.y * b.y);
}

real vector_product(const RealVector& a, const RealVector& b) {
  return (a.x * b.y - b.x * a.y);
}

real angle_between(const RealVector& a, const RealVector& b) { // from 0 to PI
  return acosl(scalar_product(a, b) / (a.length() * b.length()));
}
//____________________________________________________________________________________

int main() {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
  std::cout.precision(20);
  //________________________________________

  uint64_t N;
  int64_t l, r;
  std::cin >> N >> l >> r;
  int64_t x, y, a;
  std::vector<std::pair<Point, int64_t>> Lighthouses;
  for (uint64_t i = 0; i < N; ++i) {
    std::cin >> x >> y >> a;
    Lighthouses.emplace_back(Point(x, y), a);
  }

  std::vector<real> dp(1 << N, l);
  for (uint64_t mask = 1; mask < (1 << N); ++mask) {
    for (uint64_t pos = 0; pos < N; ++pos) {
      if (is_0(dp[mask] - r))
        break;
      if ((mask >> pos) & 1) {
        uint64_t submask = mask ^ (1 << pos);
        //                  A .
        //                 /a\  .
        //                /   \   .
        //               /     \    .
        //   l__________/b     c\.....r
        //              B        C      R
        real tmp_path = dp[submask];
        RealPoint A(Lighthouses[pos].first);
        real alpha = PI * Lighthouses[pos].second / 180.0;
        real alpha_degrees = Lighthouses[pos].second;
        RealPoint B(tmp_path, 0.0);
        RealVector BA(A - B);
        real betta = angle_between(RealVector(1, 0), BA);
        real betta_degrees = 180.0 * betta / PI;
        real addiction = (not_less_0(betta_degrees + alpha_degrees - 180.0) ?
            1'000'000 : (sinl(alpha) / sinl(alpha + betta)) * BA.length());
        dp[mask] = fmaxl(dp[mask], fminl(real(r), tmp_path + addiction));
      }
    }
  }
  std::cout << dp.back() - l;
}
