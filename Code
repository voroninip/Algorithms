#include <iostream>
#include <utility>
#include <vector>

//____________________________________________________________________________________
namespace Geometry {
struct Point {
  int64_t x;
  int64_t y;
  Point() = default;
  Point(const Point&) = default;
  ~Point() = default;
  explicit Point(int64_t x, int64_t y): x(x), y(y) {}

  friend std::ostream& operator<< (std::ostream& output, const Point& A) {
    output << A.x << ' ' << A.y;
    return output;
  }
};

Point operator+ (const Point& A, const Point& B) {
  return Point(A.x + B.x, A.y + B.y);
}

Point operator- (const Point& A, const Point& B) {
  return Point(A.x - B.x, A.y - B.y);
}

Point operator* (const Point& A, int64_t k) {
  return Point(A.x * k, A.y * k);
}

bool operator== (const Point& A, const Point& B) {
  return ((A.x == B.x) and (A.y == B.y));
}

bool operator!= (const Point& A, const Point& B) {
  return !((A.x == B.x) and (A.y == B.y));
}
//____________________________________________________________________________________
struct Vector {
  int64_t x;
  int64_t y;
  Vector() = default;
  Vector(const Vector&) = default;
  ~Vector() = default;
  explicit Vector(int64_t x, int64_t y): x(x), y(y) {}
  explicit Vector(const Point& A): x(A.x), y(A.y) {}

  friend std::ostream& operator<< (std::ostream& output, const Vector& v) {
    output << v.x << ' ' << v.y;
    return output;
  }
};

Vector operator+ (const Vector& a, const Vector& b) noexcept {
  return Vector(a.x + b.x, a.y + b.y);
}

Vector operator- (const Vector& a, const Vector& b) noexcept {
  return Vector(a.x - b.x, a.y - b.y);
}

Vector operator* (const Vector& v, int64_t k) {
  return Vector(v.x * k, v.y * k);
}

bool operator== (const Vector& a, const Vector& b) {
  return ((a.x == b.x) and (a.y == b.y));
}

int64_t scalar_product(const Vector& a, const Vector& b) {
  return (a.x * b.x + a.y * b.y);
}

int64_t vector_product(const Vector& a, const Vector& b) {
  return (a.x * b.y - b.x * a.y);
}
//____________________________________________________________________________________
struct Segment {
  Point A;
  Point B;

  Segment() = default;
  Segment(const Segment&) = default;
  ~Segment() = default;
  explicit Segment(const Point& A, const Point& B): A(A), B(B) {}
};
//____________________________________________________________________________________
bool on_segment(const Point& C, const Segment& I) {
  return vector_product(Vector(C - I.A), Vector(C - I.B)) == 0 
  and scalar_product(Vector(C - I.A), Vector(C - I.B)) <= 0;
}

bool inside_segment(const Point& C, const Segment& I) {
  return vector_product(Vector(C - I.A), Vector(C - I.B)) == 0 
  and scalar_product(Vector(C - I.A), Vector(C - I.B)) < 0;
}
//____________________________________________________________________________________
struct Polygon {
  std::vector<Point> vertices;
  Polygon() = default;
  ~Polygon() = default;
  explicit Polygon(std::vector<Point> vertices): vertices(std::move(vertices)) {}

  uint64_t size() const {
    return vertices.size();
  }
};

Polygon Minkowski_sum(const Polygon& M1, const Polygon& M2) { 
  // both polygons are oriented counter-clockwise
  std::vector<Point> Sum;
  uint64_t N1 = M1.size();
  uint64_t N2 = M2.size();
  Point L1 = M1.vertices[0];
  uint64_t START1 = 0;
  for (uint64_t i = 0; i < N1; ++i) {
    Point Tmp = M1.vertices[i];
    if ((Tmp.x < L1.x) or (Tmp.x == L1.x and Tmp.y < L1.y)) {
      L1 = Tmp;
      START1 = i;
    }
  }

  Point L2 = M2.vertices[0];
  uint64_t START2 = 0;
  for (uint64_t i = 0; i < N2; ++i) {
    Point Tmp = M2.vertices[i];
    if ((Tmp.x < L2.x) or (Tmp.x == L2.x and Tmp.y < L2.y)) {
      L2 = Tmp;
      START2 = i;
    }
  }

  Sum.push_back(L1 + L2);
  uint64_t tmp1 = START1;
  uint64_t tmp2 = START2;
  bool moved1 = false;
  bool moved2 = false;

  while (true) {
    if (tmp1 == START1 % N1 and moved1) {
      while (tmp2 != START2 % N2) {
        Point Tmp2 = M2.vertices[tmp2 % N2];
        Point Next2 = M2.vertices[(tmp2 + 1) % N2];
        Sum.push_back(Sum.back() + (Next2 - Tmp2));
        tmp2 = (tmp2 + 1) % N2;
      }
      Sum.pop_back();
      return Polygon(Sum);
    }
    if (tmp2 == START2 % N2 and moved2) {
      while (tmp1 != START1 % N1) {
        Point Tmp1 = M1.vertices[tmp1 % N1];
        Point Next1 = M1.vertices[(tmp1 + 1) % N1];
        Sum.push_back(Sum.back() + (Next1 - Tmp1));
        tmp1 = (tmp1 + 1) % N1;
      }
      Sum.pop_back();
      return Polygon(Sum);
    }
    Point Tmp1 = M1.vertices[tmp1 % N1];
    Point Next1 = M1.vertices[(tmp1 + 1) % N1];
    Point Tmp2 = M2.vertices[tmp2 % N2];
    Point Next2 = M2.vertices[(tmp2 + 1) % N2];
    if (vector_product(Vector(Next1 - Tmp1), Vector(Next2 - Tmp2)) > 0) {
      Sum.push_back(Sum.back() + (Next1 - Tmp1));
      tmp1 = (tmp1 + 1) % N1;
      moved1 = true;
      continue;
    }
    if (vector_product(Vector(Next1 - Tmp1), Vector(Next2 - Tmp2)) < 0) {
      Sum.push_back(Sum.back() + (Next2 - Tmp2));
      tmp2 = (tmp2 + 1) % N2;
      moved2 = true;
      continue;
    }
    if (vector_product(Vector(Next1 - Tmp1), Vector(Next2 - Tmp2)) == 0) {
      Sum.push_back(Sum.back() + ((Next1 - Tmp1) + (Next2 - Tmp2)));
      tmp1 = (tmp1 + 1) % N1;
      tmp2 = (tmp2 + 1) % N2;
      moved1 = true;
      moved2 = true;
      continue;
    }
  }
}
//____________________________________________________________________________________
enum class Location {
  INSIDE, BOUNDARY, OUTSIDE
};

std::ostream& operator<< (std::ostream& output, const Location& WHERE) {
  switch (WHERE) {
    case Location::INSIDE:
      output << "INSIDE";
      break;
    case Location::OUTSIDE:
      output << "OUTSIDE";
      break;
    case Location::BOUNDARY:
      output << "BOUNDARY";
      break;
  }
  return output;
}

Location relatively_convex_polygon(const Point& A, const Polygon& P, uint64_t l = 0,
                                   uint64_t r = 0) {
  if (l == 0) {
    Point P0 = P.vertices[0];
    Point P1 = P.vertices[1];
    Point Last = P.vertices.back();
    int64_t rotation_to_first = vector_product(Vector(A - P0),
                                               Vector(P1 - P0)) ;
    int64_t rotation_to_last = vector_product(Vector(A - P0),
                                              Vector(Last - P0)) ;
    if (rotation_to_first > 0 or rotation_to_last < 0) {
      return Location::OUTSIDE;
    }
    if (rotation_to_first == 0) {
      if (on_segment(A, Segment(P0, P1))) {
        return Location::BOUNDARY;
      } else {
        return Location::OUTSIDE;
      }
    }
    if (rotation_to_last == 0) {
      if (on_segment(A, Segment(P0, Last))) {
        return Location::BOUNDARY;
      } else {
        return Location::OUTSIDE;
      }
    }
    l = 1;
    r = P.size() - 1;
  }
  if (r - l == 1) {
    Point L = P.vertices[0];
    Point U = P.vertices[r];
    Point D = P.vertices[l];
    if (A == L or A == U or A == D) {
      return Location::BOUNDARY;
    }
    int64_t square_difference = vector_product(Vector(A - L),
                                               Vector(U - L))
        + vector_product(Vector(D - L), Vector(A - L))
        - vector_product(Vector(D - L), Vector(U - L));
    if (square_difference == 0) {
      return Location::BOUNDARY;
    }
    if (square_difference < 0) {
      return Location::INSIDE;
    }
    if (square_difference > 0) {
      return Location::OUTSIDE;
    }
  }
  Point P0 = P.vertices[0];
  uint64_t m = (l + r) / 2;
  Point M = P.vertices[m];
  int64_t rotation = vector_product(Vector(A - P0), Vector(M - P0));
  if (rotation == 0) {
    if (A == P0 or A == M) {
      return Location::BOUNDARY;
    }
    if (inside_segment(A, Segment(P0, M))) {
      return Location::INSIDE;
    }
    return Location::OUTSIDE;
  }
  if (rotation > 0) {
    return relatively_convex_polygon(A, P, l, m);
  }
  if (rotation < 0) {
    return relatively_convex_polygon(A, P, m, r);
  }
  return Location::BOUNDARY;
}
}
//____________________________________________________________________________________

int main() {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
  std::cout.precision(20);

  std::vector<Geometry::Point> vertices1;
  std::vector<Geometry::Point> vertices2;
  std::vector<Geometry::Point> vertices3;

  uint64_t N;
  int64_t x, y;
  int64_t prevx, prevy;
  std::cin >> N;
  vertices1.reserve(N);
  for (uint64_t i = 0; i < N; ++i) {
    std::cin >> x >> y;
    if (i >= 1 and prevx == x and prevy == y) { // unnecessary - if polygon is simple
      continue;
    }
    vertices1.emplace_back(x, y);
    prevx = x;
    prevy = y;
  }

  std::cin >> N;
  vertices2.reserve(N);
  for (uint64_t i = 0; i < N; ++i) {
    std::cin >> x >> y;
    if (i >= 1 and prevx == x and prevy == y) { // unnecessary - if polygon is simple
      continue;
    }
    vertices2.emplace_back(x, y);
    prevx = x;
    prevy = y;
  }

  std::cin >> N;
  vertices3.reserve(N);
  for (uint64_t i = 0; i < N; ++i) {
    std::cin >> x >> y;
    if (i >= 1 and prevx == x and prevy == y) { // unnecessary - if polygon is simple
      continue;
    }
    vertices3.emplace_back(x, y);
    prevx = x;
    prevy = y;
  }

  const Geometry::Polygon& First_Sum =
      Minkowski_sum(Geometry::Polygon(vertices1),
                    Geometry::Polygon(vertices2));
  const Geometry::Polygon& Sum = 
      Minkowski_sum(First_Sum, Geometry::Polygon(vertices3));
  uint64_t q;
  std::cin >> q;
  for (uint64_t i = 0; i < q; ++i) {
    std::cin >> x >> y;
    if (relatively_convex_polygon(Geometry::Point(3 * x, 3 * y), Sum) 
    != Geometry::Location::OUTSIDE) {
      std::cout << "YES\n";
    } else {
      std::cout << "NO\n";
    }
  }
}
